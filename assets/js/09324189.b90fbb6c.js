"use strict";(self.webpackChunkarchetype_docs=self.webpackChunkarchetype_docs||[]).push([[6907],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return u}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),l=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(o.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),m=l(n),u=r,k=m["".concat(o,".").concat(u)]||m[u]||d[u]||i;return n?a.createElement(k,s(s({ref:t},c),{},{components:n})):a.createElement(k,s({ref:t},c))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=m;var p={};for(var o in t)hasOwnProperty.call(t,o)&&(p[o]=t[o]);p.originalType=e,p.mdxType="string"==typeof e?e:r,s[1]=p;for(var l=2;l<i;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3372:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return o},default:function(){return u},frontMatter:function(){return p},metadata:function(){return l},toc:function(){return d}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),s=["components"],p={sidebar_position:3},o="Control",l={unversionedId:"reference/instructions/control",id:"reference/instructions/control",title:"Control",description:"if",source:"@site/docs/reference/instructions/control.md",sourceDirName:"reference/instructions",slug:"/reference/instructions/control",permalink:"/archetype-docs/docs/reference/instructions/control",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/reference/instructions/control.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docsSidebar",previous:{title:"Assignment",permalink:"/archetype-docs/docs/reference/instructions/assignment"},next:{title:"Divergent",permalink:"/archetype-docs/docs/reference/instructions/divergent"}},c={},d=[{value:"<code>if</code>",id:"if",level:2},{value:"<code>match with</code>",id:"match-with",level:2},{value:"Option",id:"option",level:3},{value:"Or",id:"or",level:3},{value:"List",id:"list",level:3},{value:"States",id:"states",level:3},{value:"Enumeration",id:"enumeration",level:3},{value:"<code>for</code>",id:"for",level:2},{value:"Set",id:"set",level:3},{value:"List",id:"list-1",level:3},{value:"Map",id:"map",level:3},{value:"Asset",id:"asset",level:3},{value:"<code>while</code>",id:"while",level:2},{value:"<code>iter</code>",id:"iter",level:2}],m={toc:d};function u(e){var t=e.components,n=(0,r.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"control"},"Control"),(0,i.kt)("h2",{id:"if"},(0,i.kt)("inlineCode",{parentName:"h2"},"if")),(0,i.kt)("p",null,"The conditional branching instruction ",(0,i.kt)("inlineCode",{parentName:"p"},"if e then i")," executes instruction ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," if the ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/types#bool"},"bool")," expression ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,i.kt)("p",null,"For example, ",(0,i.kt)("em",{parentName:"p"},"instr1")," is executed if ",(0,i.kt)("em",{parentName:"p"},"expr1")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"if expr1 then\n  instr1\n")),(0,i.kt)("p",null,"The instruction to execute when expression ",(0,i.kt)("em",{parentName:"p"},"expr1")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," follows the ",(0,i.kt)("inlineCode",{parentName:"p"},"else")," keyword:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"if expr1 then\n  instr1\nelse\n  instr2\n")),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/instructions/sequence"},"sequence")," of instructions is delimited by ",(0,i.kt)("inlineCode",{parentName:"p"},"begin ... end")," and  instructions are separated by ",(0,i.kt)("inlineCode",{parentName:"p"},";"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"if expr1 then begin\n  instr1;\n  instr2\nend else begin\n  instr3;\n  instr4\nend\n")),(0,i.kt)("p",null,"A dangling ",(0,i.kt)("inlineCode",{parentName:"p"},"else")," is attached to the ",(0,i.kt)("em",{parentName:"p"},"last")," ",(0,i.kt)("inlineCode",{parentName:"p"},"if"),". For example in the following expression, the ",(0,i.kt)("inlineCode",{parentName:"p"},"else")," branch is attached to ",(0,i.kt)("inlineCode",{parentName:"p"},"if b = 1 then a := 42")," instruction:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"if a = 1 then\n  if b = 1 then\n    a := 42\nelse\n  b := 42\n")),(0,i.kt)("p",null,"That is that it is equivalent to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"/* 'begin end' is optional here, it is to emphasis the logical structure */\nif a = 1 then begin\n  if b = 1 then\n    a := 42\n  else\n    b := 42\nend\n")),(0,i.kt)("p",null,"Note that there is no need for parenthesis in the bool expression; for example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"var max : nat = 0;\nif a < b then\n  max := b\nelse\n  max := a\n")),(0,i.kt)("p",null,"A conditional ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/expressions/controls#if"},(0,i.kt)("inlineCode",{parentName:"a"},"if"))," ",(0,i.kt)("em",{parentName:"p"},"expression")," is also available."),(0,i.kt)("h2",{id:"match-with"},(0,i.kt)("inlineCode",{parentName:"h2"},"match with")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"match with")," instruction, inspired by the ",(0,i.kt)("a",{parentName:"p",href:"https://ocaml.org/"},"Ocaml")," language, desconstructs a value of ",(0,i.kt)("em",{parentName:"p"},"enumerated")," type to extract data from it. Enumerated types are ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/types#option%3CT%3E"},(0,i.kt)("inlineCode",{parentName:"a"},"option")),", ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/types#or%3CT1,%20T2%3E"},(0,i.kt)("inlineCode",{parentName:"a"},"or")),", ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/types#list%3CT%3E"},(0,i.kt)("inlineCode",{parentName:"a"},"list")),", ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/declarations/compositetypes#states"},(0,i.kt)("inlineCode",{parentName:"a"},"states"))," and composite type ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/types#enum"},(0,i.kt)("inlineCode",{parentName:"a"},"enum")),"."),(0,i.kt)("p",null,"Its generic syntactic structure is presented below, given that ",(0,i.kt)("em",{parentName:"p"},"E1")," ... ",(0,i.kt)("em",{parentName:"p"},"En")," are the named values of the enumerated type of ",(0,i.kt)("em",{parentName:"p"},"expr1"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"match expr1 with\n| E1 -> instr1 /* instruction when expr1 is E1 */\n| E2 -> instr2 /* instruction when expr1 is E2 */\n/* ... */\n| En -> instrn /* instruction when expr1 is En */\nend\n")),(0,i.kt)("p",null,"If one named type ",(0,i.kt)("em",{parentName:"p"},"Ei")," is missing, the compiler fails with the message:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Partial match (missing "Ei")\n')),(0,i.kt)("p",null,"It is possible to escape the enumeration with the ",(0,i.kt)("inlineCode",{parentName:"p"},"_")," keyword; for example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"match expr1 with\n| E1 -> instr1\n| E2 -> instr2\n| _  -> instr3  /* instruction when expr1 is E3 or E4 ... or En */\nend\n")),(0,i.kt)("h3",{id:"option"},"Option"),(0,i.kt)("p",null,"An ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/types#option%3CT%3E"},(0,i.kt)("inlineCode",{parentName:"a"},"option"))," value has two named values: ",(0,i.kt)("inlineCode",{parentName:"p"},"some")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"none"),"."),(0,i.kt)("p",null,"For example, suppose ",(0,i.kt)("inlineCode",{parentName:"p"},"opt")," is typed ",(0,i.kt)("inlineCode",{parentName:"p"},"option<string>"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"match opt with\n| some(s) -> instr1 /* declares constant 's' typed 'string' in instr1 */\n| none    -> instr2\nend\n")),(0,i.kt)("h3",{id:"or"},"Or"),(0,i.kt)("p",null,"An ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/types#or%3CT1,%20T2%3E"},(0,i.kt)("inlineCode",{parentName:"a"},"or"))," value has two named values: ",(0,i.kt)("inlineCode",{parentName:"p"},"left")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"right"),"."),(0,i.kt)("p",null,"For example, suppose ",(0,i.kt)("inlineCode",{parentName:"p"},"o")," is typed ",(0,i.kt)("inlineCode",{parentName:"p"},"or<string, nat>"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"match o with\n| left(s)  -> instr1 /* declares constant 's' typed 'string' in instr1 */\n| right(n) -> instr2 /* declares constant 'n' typed 'nat' in instr2    */\nend\n")),(0,i.kt)("h3",{id:"list"},"List"),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/types#list%3CT%3E"},(0,i.kt)("inlineCode",{parentName:"a"},"list"))," value has two named values: ",(0,i.kt)("inlineCode",{parentName:"p"},"[]")," for empty list and ",(0,i.kt)("inlineCode",{parentName:"p"},"::")," for recursive composition."),(0,i.kt)("p",null,"For example, suppose ",(0,i.kt)("inlineCode",{parentName:"p"},"l")," is typed ",(0,i.kt)("inlineCode",{parentName:"p"},"list<bytes>"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"match l with\n| h::tl -> instr1 /* declares constants h typed 'bytes' and tl typed 'list<bytes' */\n| []    -> instr2 /* when l is empty */\nend\n")),(0,i.kt)("p",null,"In the example above, ",(0,i.kt)("inlineCode",{parentName:"p"},"h")," is the first element of the list ",(0,i.kt)("inlineCode",{parentName:"p"},"l"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"tl")," is the list ",(0,i.kt)("inlineCode",{parentName:"p"},"l")," without the first element."),(0,i.kt)("p",null,"Note that Archetype does not support recursive calls, hence the ",(0,i.kt)("inlineCode",{parentName:"p"},"match")," instruction cannot be used to fold a list as in Ocaml; it is rather used to retrieve the first element of a list and manage the case of an empty list. The ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/instructions/control#for"},(0,i.kt)("inlineCode",{parentName:"a"},"for"))," instruction is used to iterate over list elements."),(0,i.kt)("h3",{id:"states"},"States"),(0,i.kt)("p",null,"Contract's ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/declarations/compositetypes#states"},(0,i.kt)("inlineCode",{parentName:"a"},"states"))," may be interrogated with the ",(0,i.kt)("inlineCode",{parentName:"p"},"match")," instruction."),(0,i.kt)("p",null,"Consider the states declaration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"states =\n| Pending initial\n| Shipped\n| Accepted\n| Canceled\n")),(0,i.kt)("p",null,"The following enables acting based on contract's state:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"match state with\n| Pending  -> instr1 /* when in Pending  state */\n| Shipped  -> instr2 /* when in Shipped  state */\n| Accepted -> instr3 /* when in Accepted state */\n| Canceled -> instr4 /* when in Canceled state */\nend;\n")),(0,i.kt)("h3",{id:"enumeration"},"Enumeration"),(0,i.kt)("p",null,"An ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/types#enum"},(0,i.kt)("inlineCode",{parentName:"a"},"enum"))," value has a user-defined list of values."),(0,i.kt)("p",null,"Consider the following declaration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"enum color =\n| RGB<nat * nat * nat>\n| Hex<bytes>\n| Css<string>\n")),(0,i.kt)("p",null,"The following enables acting based on ",(0,i.kt)("inlineCode",{parentName:"p"},"color"),"'s values:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"match color with\n| RGB(rgb) -> instr1 /* declares 'rgb' as a tuple of 3 values typed 'nat' in instr1 */\n| Hex(h)   -> instr2 /* declares 'h' as a bytes value in instr2                     */\n| Css(css) -> instr3 /* declares 'css' as a string value in instr3                  */\nend\n")),(0,i.kt)("h2",{id:"for"},(0,i.kt)("inlineCode",{parentName:"h2"},"for")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," instruction iterates the elements of a ",(0,i.kt)("em",{parentName:"p"},"container")," (",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/types#set%3CT%3E"},(0,i.kt)("inlineCode",{parentName:"a"},"set")),", ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/types#list%3CT%3E"},(0,i.kt)("inlineCode",{parentName:"a"},"list")),", ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/types#map%3CK,%20V%3E"},(0,i.kt)("inlineCode",{parentName:"a"},"map"))," and ",(0,i.kt)("a",{parentName:"p",href:"/docs/asset"},(0,i.kt)("inlineCode",{parentName:"a"},"asset")),")."),(0,i.kt)("p",null,"The generic syntax structure is presented below, given ",(0,i.kt)("inlineCode",{parentName:"p"},"c")," is a container:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"for e in c do\n  instr1      /* declares constant element 'e' in instr1 */\ndone\n")),(0,i.kt)("p",null,"The type of element ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," above depends on the type of the container. See below for more information."),(0,i.kt)("p",null,"Note that it is ",(0,i.kt)("em",{parentName:"p"},"not")," possible to break an iteration. See the ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/expressions/builtins#fold%20(i%20:%20or%3CL,%20R%3E,%20id%20-%3E%20(body(id%20:%20L)%20:%20or%3CL,%20R%3E))"},(0,i.kt)("inlineCode",{parentName:"a"},"fold"))," builtin for an iteration process with a possiblity to break."),(0,i.kt)("h3",{id:"set"},"Set"),(0,i.kt)("p",null,"Elements of a ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/types#set%3CT%3E"},(0,i.kt)("inlineCode",{parentName:"a"},"set"))," are iterated in the element's type natural order."),(0,i.kt)("p",null,"For example, suppose set ",(0,i.kt)("inlineCode",{parentName:"p"},"s")," is typed ",(0,i.kt)("inlineCode",{parentName:"p"},"set<string>"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"for e in s do\n  instr1 /* constant e is typed 'string' and is an element of s */\ndone\n")),(0,i.kt)("h3",{id:"list-1"},"List"),(0,i.kt)("p",null,"Elements of a ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/types#list%3CT%3E"},(0,i.kt)("inlineCode",{parentName:"a"},"list"))," are iterated in the order of the list's construction process. See ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/instructions/containers#lprepende"},(0,i.kt)("inlineCode",{parentName:"a"},"prepend"))," and ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/instructions/containers#lconcatl"},(0,i.kt)("inlineCode",{parentName:"a"},"concat"))," instructions."),(0,i.kt)("p",null,"For example, suppose list ",(0,i.kt)("inlineCode",{parentName:"p"},"l")," is typed ",(0,i.kt)("inlineCode",{parentName:"p"},"list<nat>"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"for e in l do\n  instr1 /* constant 'e' is typed `nat` */\ndone\n")),(0,i.kt)("h3",{id:"map"},"Map"),(0,i.kt)("p",null,"Elements of a ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/types#map%3CK,%20V%3E"},(0,i.kt)("inlineCode",{parentName:"a"},"map"))," ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/types#big_map%3CK,%20V%3E"},(0,i.kt)("inlineCode",{parentName:"a"},"big_map"))," or ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/types#iterable_big_map%3CK,%20V%3E"},(0,i.kt)("inlineCode",{parentName:"a"},"iterable_big_map"))," are iterated in the natural order of the key."),(0,i.kt)("p",null,"For example, suppose map ",(0,i.kt)("inlineCode",{parentName:"p"},"m")," is typed ",(0,i.kt)("inlineCode",{parentName:"p"},"map<string, bytes>"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"for (k, v) in m do\n  instr1\nend\n")),(0,i.kt)("p",null,"In the example above:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"k")," is a key of the map typed ",(0,i.kt)("inlineCode",{parentName:"li"},"string")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"v")," is the associated value typed ",(0,i.kt)("inlineCode",{parentName:"li"},"bytes"))),(0,i.kt)("h3",{id:"asset"},"Asset"),(0,i.kt)("p",null,"Elements of a ",(0,i.kt)("a",{parentName:"p",href:"/docs/asset"},(0,i.kt)("inlineCode",{parentName:"a"},"asset"))," are iterated in the natural order of the asset identifier."),(0,i.kt)("p",null,"Consider the following ",(0,i.kt)("inlineCode",{parentName:"p"},"visitor")," asset declaration identified by ",(0,i.kt)("inlineCode",{parentName:"p"},"login")," field:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"asset visitor identified by login {\n  login    : address;\n  fullname : string;\n  nbvisits : nat = 0\n}\n")),(0,i.kt)("p",null,"The following iterates on the ",(0,i.kt)("inlineCode",{parentName:"p"},"visitor")," asset collection:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"for log in visitor do\n  instr1 /* 'log' is the visitor 'login' typed 'address' */\ndone\n")),(0,i.kt)("p",null,"Since ",(0,i.kt)("inlineCode",{parentName:"p"},"log")," is the iterated visitor's login, visitor data is accessed with ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/expressions/asset#ak--asset_keyaf"},(0,i.kt)("inlineCode",{parentName:"a"},"[]"))," operator, like for example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"var nbv = visitor[log].nbvisits\n")),(0,i.kt)("h2",{id:"while"},(0,i.kt)("inlineCode",{parentName:"h2"},"while")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"while")," instruction executes an instruction as long as a condition holds true."),(0,i.kt)("p",null,"The generic syntax is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"while expr1 do\n  instr1\ndone\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("em",{parentName:"p"},"expr1")," is a ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/types#bool"},(0,i.kt)("inlineCode",{parentName:"a"},"bool"))," typed expression."),(0,i.kt)("p",null,"For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"var i = 0;\nwhile i < 20 do\n  instr1;\n  i += 1\ndone\n")),(0,i.kt)("div",{className:"admonition admonition-danger alert alert--danger"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"danger")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"There is no guarantee that the iteration terminates. In such a case the entrypoint fails with a ",(0,i.kt)("inlineCode",{parentName:"p"},"gas exceeded")," error."))),(0,i.kt)("h2",{id:"iter"},(0,i.kt)("inlineCode",{parentName:"h2"},"iter")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"iter")," instruction iterates over a integer value in a specified range. The generic syntax is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"iter i from expr1 to expr2 do\n  instr1 /* declares an integer constant 'i' between expr1 and expr2 included */\ndone\n")),(0,i.kt)("p",null,"In the instruction above, ",(0,i.kt)("em",{parentName:"p"},"expr1")," and ",(0,i.kt)("em",{parentName:"p"},"expr2")," are expressions typed ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/types#nat"},(0,i.kt)("inlineCode",{parentName:"a"},"int")),". It does not iterate if ",(0,i.kt)("em",{parentName:"p"},"expr1")," is greater than ",(0,i.kt)("em",{parentName:"p"},"expr2"),"."),(0,i.kt)("p",null,"The initial ",(0,i.kt)("inlineCode",{parentName:"p"},"from")," value may be omitted, it is then defaulted to ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-archetype"},"iter i to expr2 do\n  instr1 /* declares an integer constant 'i' between 1 and expr2 included */\ndone\n")))}u.isMDXComponent=!0}}]);